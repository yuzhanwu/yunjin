## 底层结构

###基本机构
由数组和链表组合构成的数据结构 java8之后链表有红黑树的部分

数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node

![](https://gitee.com/yzwater/yunjin/blob/master/image/hashmap1.jpg)

因为他本身所有的位置都为null，在put插入的时候会根据key的hash去计算一个index值。

就比如我put（”允瑾“，520），我插入了为”帅丙“的元素，这个时候我们会通过哈希函数计算出插入的位置，计算出来index是2那结果如下。

> hash（“允瑾”）= 2

###链表

>为什么使用链表

我们都知道数组长度是有限的，在有限的长度里面我们使用哈希，哈希本身就存在概率性，就是”帅丙“和”丙帅“我们都去hash有一定的概率会一样，就像上面的情况我再次哈希”允瑾“极端情况也会hash到一个值上，那就形成了链表。

## 扩容
### 为什么扩容

数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容
### 什么时候扩容

•  Capacity：HashMap当前长度。

•  LoadFactor：负载因子，默认值0.75f。

•  当实际容量大于capacity*loadfactor时扩容

### 怎么扩容

•	扩容：创建一个新的Entry空数组，长度是原数组的2倍。

•	ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。

### 为什么要重新Hash

是因为长度扩大以后，Hash的规则也随之改变。

Hash的公式---> index = HashCode（Key） & （Length - 1）

说到链表我想问一下，你知道新的Entry节点在插入链表的时候，是怎么插入的么？

Java8之前是头插法，java8之后是尾插法

由于扩容后重新计算了位置，头插法可能会导致A->B->A形成环形链表

>HashMap的默认初始化长度是多少？ 16

太小了就有可能频繁发生扩容，影响效率。太大了又浪费空间，不划算。
底层计算位运算，2的次幂效率更高
为什么重写hashcode和equals方法
如果yz 和zy通过hashcode后放在同一个key里面，具体的值要通过equals获取具体的值


